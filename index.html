<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>Recomendador de Artistas - Spotify</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #191414;
      color: #FFFFFF;
      font-family: Arial, sans-serif;
    }
    h1, h2, h3 {
      text-align: center;
    }
    #app {
      padding: 20px;
    }
    #genreList {
      list-style: none;
      padding: 0;
      margin: 0 auto;
      max-width: 600px;
    }
    #genreList li {
      background-color: #1DB954;
      margin: 5px 0;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      text-align: center;
      transition: background-color 0.3s;
    }
    #genreList li:hover {
      background-color: #17a44d;
    }
    .genre-section {
      margin-top: 30px;
    }
    .cards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    .artist-card {
      background-color: #282828;
      border-radius: 5px;
      padding: 10px;
      width: 150px;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .artist-card img {
      width: 100%;
      border-radius: 5px;
    }
    @media (max-width: 600px) {
      .artist-card {
        width: calc(50% - 10px);
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <h1>Recomendador de Artistas</h1>
    <div id="loading">Carregando dados...</div>
    <div id="genres" style="display:none;">
      <h2>Gêneros das suas músicas salvas</h2>
      <ul id="genreList"></ul>
    </div>
    <div id="results"></div>
  </div>
  <script>
    function setWithExpiry(key, value, ttl) {
      const now = new Date().getTime();
      const item = { value: value, expiry: now + ttl };
      localStorage.setItem(key, JSON.stringify(item));
    }
    function getWithExpiry(key) {
      const itemStr = localStorage.getItem(key);
      if (!itemStr) return null;
      const item = JSON.parse(itemStr);
      const now = new Date().getTime();
      if (now > item.expiry) {
        localStorage.removeItem(key);
        return null;
      }
      return item.value;
    }
    const clientId = 'cdbe0b644b984a6e98839e352d87bb3d';
    const redirectUri = 'https://gandradeiasi.github.io/recomendador-de-artista-3/';
    const scopes = 'user-top-read user-library-read';
    function getAccessToken() {
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      const token = params.get('access_token');
      return token;
    }
    function redirectToAuth() {
      const authEndpoint = 'https://accounts.spotify.com/authorize';
      const url = authEndpoint + '?client_id=' + clientId + '&redirect_uri=' + encodeURIComponent(redirectUri) + '&response_type=token&scope=' + encodeURIComponent(scopes);
      window.location = url;
    }
    const accessToken = getAccessToken();
    if (!accessToken) {
      redirectToAuth();
    }
    async function spotifyFetch(url) {
      const response = await fetch(url, {
        headers: { 'Authorization': 'Bearer ' + accessToken }
      });
      if (!response.ok) {
        throw new Error('Erro na requisição: ' + response.status);
      }
      return response.json();
    }
    async function fetchAll(url) {
      let items = [];
      while (url) {
        const data = await spotifyFetch(url);
        if (data.items) {
          items = items.concat(data.items);
        }
        url = data.next;
      }
      return items;
    }
    async function getSavedTracks() {
      const url = 'https://api.spotify.com/v1/me/tracks?limit=50';
      const items = await fetchAll(url);
      return items.map(item => item.track);
    }
    async function getTopTracks() {
      const url = 'https://api.spotify.com/v1/me/top/tracks?limit=50&time_range=medium_term';
      const data = await spotifyFetch(url);
      return data.items;
    }
    async function getArtistsDetails(artistIds) {
      const chunks = [];
      for (let i = 0; i < artistIds.length; i += 50) {
        chunks.push(artistIds.slice(i, i + 50));
      }
      let artists = [];
      for (const chunk of chunks) {
        const url = 'https://api.spotify.com/v1/artists?ids=' + chunk.join(',');
        const data = await spotifyFetch(url);
        artists = artists.concat(data.artists);
      }
      return artists;
    }
    function extractArtistIds(tracks) {
      const ids = new Set();
      tracks.forEach(track => {
        if (track && track.artists) {
          track.artists.forEach(artist => ids.add(artist.id));
        }
      });
      return Array.from(ids);
    }
    function createArtistDetailsMap(artistsArray) {
      const map = {};
      artistsArray.forEach(artist => {
        map[artist.id] = artist;
      });
      return map;
    }
    function countGenres(savedTracks, artistDetailsMap) {
      const genreCounts = {};
      savedTracks.forEach(track => {
        if (track && track.artists) {
          track.artists.forEach(artist => {
            const details = artistDetailsMap[artist.id];
            if (details && details.genres) {
              details.genres.forEach(genre => {
                genreCounts[genre] = (genreCounts[genre] || 0) + 1;
              });
            }
          });
        }
      });
      return genreCounts;
    }
    function computeForbiddenArtists(savedTracks, topTracks) {
      const savedSet = new Set();
      savedTracks.forEach(track => {
        if (track && track.artists) {
          track.artists.forEach(artist => savedSet.add(artist.id));
        }
      });
      const topSet = new Set();
      topTracks.forEach(track => {
        if (track && track.artists) {
          track.artists.forEach(artist => topSet.add(artist.id));
        }
      });
      const intersection = new Set();
      savedSet.forEach(id => {
        if (topSet.has(id)) {
          intersection.add(id);
        }
      });
      return intersection;
    }
    function displayGenres(sortedGenres) {
      const genreList = document.getElementById('genreList');
      genreList.innerHTML = '';
      sortedGenres.forEach(([genre, count]) => {
        const li = document.createElement('li');
        li.textContent = genre + ' (' + count + ')';
        li.addEventListener('click', () => {
          searchArtistsByGenre(genre);
        });
        genreList.appendChild(li);
      });
      document.getElementById('genres').style.display = 'block';
    }
    function createArtistCard(artist) {
      const card = document.createElement('div');
      card.className = 'artist-card';
      const img = document.createElement('img');
      if (artist.images && artist.images.length > 0) {
        img.src = artist.images[0].url;
      } else {
        img.src = 'https://via.placeholder.com/150';
      }
      const name = document.createElement('div');
      name.textContent = artist.name;
      card.appendChild(img);
      card.appendChild(name);
      return card;
    }
    async function searchArtistsByGenre(genre) {
      let section = document.getElementById('section-' + genre);
      if (!section) {
        section = document.createElement('div');
        section.className = 'genre-section';
        section.id = 'section-' + genre;
        const title = document.createElement('h3');
        title.textContent = 'Artistas do gênero: ' + genre;
        section.appendChild(title);
        const container = document.createElement('div');
        container.className = 'cards-container';
        container.id = 'cards-' + genre;
        section.appendChild(container);
        document.getElementById('results').appendChild(section);
      } else {
        document.getElementById('cards-' + genre).innerHTML = '';
      }
      const container = document.getElementById('cards-' + genre);
      const forbidden = window.artistas_proibidos || new Set();
      const seenArtists = new Set();
      function processArtists(items) {
        items.forEach(artist => {
          if (artist.genres && artist.genres.includes(genre) && !forbidden.has(artist.id) && !seenArtists.has(artist.id)) {
            seenArtists.add(artist.id);
            const card = createArtistCard(artist);
            container.appendChild(card);
          }
        });
      }
      async function paginateSearch(query) {
        let offset = 0;
        const limit = 50;
        let total = 0;
        do {
          const searchUrl = 'https://api.spotify.com/v1/search?q=' + encodeURIComponent(query) + '&type=artist&limit=' + limit + '&offset=' + offset;
          try {
            const data = await spotifyFetch(searchUrl);
            const artistsData = data.artists;
            total = artistsData.total;
            processArtists(artistsData.items);
            offset += limit;
          } catch (error) {
            console.error('Erro na busca:', error);
            break;
          }
        } while (offset < total);
      }
      await paginateSearch('genre:' + genre);
      await paginateSearch('genre:"' + genre + '"');
    }
    async function init() {
      try {
        const [savedTracks, topTracks] = await Promise.all([getSavedTracks(), getTopTracks()]);
        const forbiddenArtistsSet = computeForbiddenArtists(savedTracks, topTracks);
        window.artistas_proibidos = forbiddenArtistsSet;
        const savedArtistIds = extractArtistIds(savedTracks);
        const artistsDetails = await getArtistsDetails(savedArtistIds);
        const artistDetailsMap = createArtistDetailsMap(artistsDetails);
        const genreCounts = countGenres(savedTracks, artistDetailsMap);
        const sortedGenres = Object.entries(genreCounts).sort((a, b) => b[1] - a[1]);
        displayGenres(sortedGenres);
        setWithExpiry('artistas_proibidos', Array.from(forbiddenArtistsSet), 86400000);
        setWithExpiry('generosRanking', sortedGenres, 86400000);
        document.getElementById('loading').style.display = 'none';
      } catch (error) {
        console.error('Erro na inicialização:', error);
        document.getElementById('loading').textContent = 'Erro ao carregar dados. Veja o console para detalhes.';
      }
    }
    init();
  </script>
</body>
</html>
